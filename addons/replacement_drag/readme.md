# How to use the replacement drag and drop addon

1. First off, get the plugin and install it into your project.  
2. Take a scene you want to be drag/droppable and add a DragControl node to it somewhere. Make sure to size the node correctly for whatever area you want to be able to be used for dragging.  
3. For the DragControl, make sure to set the texture value for the drag preview. This is an exported variable on the control. It will automatically be placed as the drag preview.  
4. Go to the scene you want to drop something into, and add a DropArea node to it somewhere. Make sure also to set the size of the DropArea node to be whatever you need it to be. Make sure for both steps 2 and 3 that you do not have any controls "above" the drag and drop scenes that would interfere with the feature, i.e. they need to have at least mouse_filter set to PASS, or just IGNORE the mouse on them altogether. The DragControl and DropArea both have their mouse settings set correctly by default, so no need to update those.  
5. In your script for whatever is draggable, connect to the needs_data(data: Dictionary) function on the DragControl class. When that signal is emitted, the data Dictionary that's a parameter will be used as the data that is put into the DropArea, so make sure it contains everything you need, such as values for stuff like types, in case the DragArea can support multiple, different things that can be dropped into it. As an example, if something can be a Sword, Shield, Axe, or Hammer and can be dropped onto a character's hand(s) to equip them, then make sure the type is set correctly for each derivative type, and that the texture matches whatever it needs to for the thing being dragged.  
6. In your script for whatever is the DropArea node, connect to the drop_requested(request: DropRequest) and data_dropped(value, at_position) signals on the DropArea. These signals work like this:  
  a. `drop_requested` will be fired whenever `_can_drop_data` (in Godot parlance) is called. That means it'll request to be dropped on anything which is drag/drop capable in the UI. It will give you, in the DropRequest, three pieces of data: the can_drop value, the data, and at_position. at_pos refers to the same position provided by Godot's drag-drop functionality in the _drop_data function, so a Vector2 that represents the actual screen position of the drop request. The data sent is the same data that was requested in the needs_data signal in step 5, and also includes the node which is being dragged itself. The `can_drop` property is one that *you* have to set the value for based on the data that's being dropped: use any values you've added to that data in order to determine if the drop is valid for the DropArea you've specified. If it is not, set the value in the DropRequest in your drop_requested signal handler to false; otherwise, set it to true if it's valid. This will make it so the system automatically allows drops only in the right places where you intend them to be dropped, and otherwise it will be canceled.    
  b. `data_dropped` will be fired when the actual node is attempted to be dropped into a DropArea. It also gives you the at_position value like above, and the data that was actually dropped. You can then do with it what you will, such as moving the item to the new place in your UI, either by removing the parent and re-parenting it somewhere, or just by moving it.  
7. Note that if you want the original item to disappear when you start dragging it, it's better to simply make it invisible yourself with the drag_started signal from the DragControl script in your handling script.
